package io.github.cyfko.projection.metamodel;

import io.github.cyfko.projection.metamodel.model.PersistenceMetadata;
import io.github.cyfko.projection.metamodel.providers.PersistenceMetadataRegistryProvider;

import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

/**
 * Provides centralized access to the JPA entity metadata registry generated at compile time.
 * <p>
 * This class acts as a facade for retrieving metadata about entity fields, including identifiers,
 * relationships, collections, and mapped IDs. It lazily loads the generated registry implementation
 * and caches it for subsequent access.
 * </p>
 *
 * <p>
 * The registry is expected to be generated by the {@code EntityRegistryProcessor} annotation processor
 * which SHOULD generates the implementation class
 * {@code io.github.cyfko.projection.metamodel.providers.PersistenceMetadataRegistryProviderImpl}.
 * </p>
 *
 * <p>
 * Typical usage:
 * <pre>{@code
 * // Get metadata for a specific entity
 * Map<String, PersistenceMetadata> metadata = PersistenceRegistry.getMetadataFor(User.class);
 *
 * // Check if entity is registered
 * boolean isRegistered = PersistenceRegistry.isEntityRegistered(User.class);
 *
 * // Get the full registry
 * EntityMetadataRegistryProvider registry = PersistenceRegistry.getEntityRegistry();
 * }</pre>
 * </p>
 *
 * <p>
 * If the registry cannot be loaded (e.g., due to missing generation or classpath issues),
 * an {@link IllegalStateException} is thrown with a detailed diagnostic message.
 * </p>
 *
 * <p><strong>Thread safety:</strong> The registry is loaded in a thread-safe manner using double-checked locking.</p>
 *
 * @author Frank Cyrille KOSSI
 * @see PersistenceMetadataRegistryProvider
 * @see PersistenceMetadata
 */
public final class PersistenceRegistry {

    private static volatile PersistenceMetadataRegistryProvider PROVIDER;
    private static final Map<Class<?>, List<String>> ENTITY_ID_FIELDS = new HashMap<>();

    // Private constructor to prevent instantiation
    private PersistenceRegistry() {
        throw new UnsupportedOperationException("PersistenceRegistry is a utility class and cannot be instantiated");
    }

    /**
     * Returns the full entity metadata registry provider.
     * <p>
     * This method uses double-checked locking to ensure thread-safe lazy initialization.
     * </p>
     *
     * @return the entity metadata registry provider
     * @throws IllegalStateException if the registry cannot be loaded
     */
    public static PersistenceMetadataRegistryProvider getEntityRegistryProvider() {
        if (PROVIDER == null) {
            synchronized (PersistenceRegistry.class) {
                if (PROVIDER == null) {
                    PROVIDER = loadProvider();
                }
            }
        }
        return PROVIDER;
    }

    /**
     * Returns metadata for all fields of the specified entity/embeddable class.
     *
     * @param entityClass the entity class to retrieve metadata for
     * @return a map of field names to their metadata, or {@code null} if the entity is not registered
     * @throws NullPointerException if entityClass is null
     */
    public static Map<String, PersistenceMetadata> getMetadataFor(Class<?> entityClass) {
        return isEntityRegistered(entityClass) ? getEntityRegistryProvider().getEntityMetadataRegistry().get(entityClass) : getEntityRegistryProvider().getEmbeddableMetadataRegistry().get(entityClass);
    }

    /**
     * Checks if the specified entity class is registered in the metadata registry.
     *
     * @param entityClass the entity class to check
     * @return {@code true} if the entity is registered, {@code false} otherwise
     * @throws NullPointerException if entityClass is null
     */
    public static boolean isEntityRegistered(Class<?> entityClass) {
        if (entityClass == null) {
            throw new NullPointerException("Entity class cannot be null");
        }
        return getEntityRegistryProvider().getEntityMetadataRegistry().containsKey(entityClass);
    }

    /**
     * Checks if the specified embeddable class is registered in the metadata registry.
     *
     * @param embeddableClass the embeddable class to check
     * @return {@code true} if the embeddable is registered, {@code false} otherwise
     * @throws NullPointerException if entityClass is null
     */
    public static boolean isEmbeddableRegistered(Class<?> embeddableClass) {
        if (embeddableClass == null) {
            throw new NullPointerException("Entity class cannot be null");
        }
        return getEntityRegistryProvider().getEmbeddableMetadataRegistry().containsKey(embeddableClass);
    }

    /**
     * Returns the total number of registered entities.
     *
     * @return the number of registered entities
     */
    public static int getRegisteredEntityCount() {
        return getEntityRegistryProvider().getEntityMetadataRegistry().size();
    }

    /**
     * Returns metadata for a specific field of the specified entity class or embeddable class.
     *
     * @param entityClass the entity class
     * @param fieldName the name of the field
     * @return the field metadata, or {@code null} if the entity or field is not found
     * @throws NullPointerException if entityClass or fieldName is null
     */
    public static PersistenceMetadata getFieldMetadata(Class<?> entityClass, String fieldName) {
        if (entityClass == null) {
            throw new NullPointerException("Entity class cannot be null");
        }
        if (fieldName == null) {
            throw new NullPointerException("Field name cannot be null");
        }

        Map<String, PersistenceMetadata> entityMetadata = getMetadataFor(entityClass);
        return entityMetadata != null ? entityMetadata.get(fieldName) : null;
    }

    /**
     * Finds the ID fields (maybe a primary key or a composite primary key) for an entity using PersistenceRegistry.
     */
    public static synchronized List<String> getIdFields(Class<?> entityClass) {
        if (ENTITY_ID_FIELDS.containsKey(entityClass)) return ENTITY_ID_FIELDS.get(entityClass);

        Map<String, PersistenceMetadata> metadata = PersistenceRegistry.getMetadataFor(entityClass);
        if (metadata == null) {
            throw new IllegalStateException("No metadata found for entity: " + entityClass.getName());
        }

        List<String> idFields = metadata.entrySet().stream()
                .filter(e -> e.getValue().isId())
                .flatMap(PersistenceRegistry::extractIdFields)
                .toList();

        if (idFields.isEmpty()) {
            throw new IllegalStateException("No @Id field found in entity: " + entityClass.getSimpleName());
        }

        ENTITY_ID_FIELDS.put(entityClass, idFields);
        return idFields;
    }

    private static Stream<String> extractIdFields(Map.Entry<String,PersistenceMetadata> entry) {
        // If embeddable then unwrap all its fields
        Class<?> clazz = entry.getValue().relatedType();
        if (PersistenceRegistry.isEmbeddableRegistered(clazz)) {
            return PersistenceRegistry.getMetadataFor(clazz).keySet().stream();
        } else {
            return Stream.of(entry.getKey());
        }
    }

    /**
     * Loads the generated registry implementation via reflection.
     * <p>
     * This method attempts to default construct the generated implementation {@code PersistenceMetadataRegistryProviderImpl} class.
     * </p>
     *
     * @return the loaded registry provider
     * @throws IllegalStateException if the registry cannot be loaded
     */
    private static PersistenceMetadataRegistryProvider loadProvider() {
        try {
            Class<?> registryClass = Class.forName(
                    "io.github.cyfko.projection.metamodel.providers.PersistenceMetadataRegistryProviderImpl"
            );
            return (PersistenceMetadataRegistryProvider) registryClass.getConstructor().newInstance();
        } catch (ClassNotFoundException e) {
            throw new IllegalStateException(
                    "Cannot load metadata registry: PersistenceMetadataRegistryProviderImpl class not found. " +
                            "Ensure that the annotation processor has run and generated the registry class. " +
                            "Check that 'io.github.cyfko:jpa-metamodel-processor' is configured as an annotation processor.",
                    e
            );
        }  catch (InvocationTargetException | InstantiationException | NoSuchMethodException | IllegalAccessException e) {
            throw new IllegalStateException(e);
        }
    }

    /**
     * Clears the cached registry. Useful for testing purposes.
     * <p>
     * <strong>Warning:</strong> This method is intended for testing only and should not be used in production code.
     * </p>
     */
    static void clearCache() {
        synchronized (PersistenceRegistry.class) {
            PROVIDER = null;
        }
    }
}