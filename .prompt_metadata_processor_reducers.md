# Traiter les Reducers dans le Metadata Processor

## Objectif

Mettre à jour le processeur d'annotations `projection-metadata-processor` pour traiter la nouvelle propriété `reducers` de l'annotation `@Computed`.

## Contexte

L'annotation `@Computed` a été étendue avec une propriété `reducers` :

```java
@Computed(
    dependsOn = {"id", "orders.total"},
    reducers = {"SUM"}
)
private BigDecimal totalOrderAmount;

// Collections imbriquées supportées
@Computed(
    dependsOn = {"departments.teams.employees.salary"},
    reducers = {"AVG"}
)
private BigDecimal avgSalary;
```

## Modifications requises

### 1. Mettre à jour le modèle [ComputedField](file:///c:/Users/KOSSI/Desktop/kunrin/filter-ql/adapters/java/filterql-jpa/src/main/java/io/github/cyfko/filterql/jpa/projection/MultiQueryExecutionPlanV2.java#481-488)

Ajouter un champ pour stocker les reducers :

```java
public record ComputedField(
    String dtoField,
    String[] dependsOn,
    String[] reducers,  // NOUVEAU
    MethodReference methodReference
) {
    public ComputedField(String dtoField, String[] dependsOn, MethodReference methodReference) {
        this(dtoField, dependsOn, new String[0], methodReference);
    }
}
```

### 2. Modifier la logique d'extraction

```java
private ComputedField processComputedField(VariableElement field) {
    Computed annotation = field.getAnnotation(Computed.class);
    
    String[] dependsOn = annotation.dependsOn();
    String[] reducers = annotation.reducers();
    
    // Validation
    validateReducers(dependsOn, reducers, field);
    
    return new ComputedField(
        field.getSimpleName().toString(),
        dependsOn,
        reducers,
        extractMethodReference(field)
    );
}
```

### 3. Validation

```java
private void validateReducers(String[] dependsOn, String[] reducers, Element field) {
    if (reducers.length == 0) {
        return; // Pas de reducers - comportement classique
    }
    
    // Identifier les dépendances de type collection (contenant '.')
    List<String> collectionDeps = Arrays.stream(dependsOn)
        .filter(d -> d.contains("."))
        .toList();
    
    // 1. Vérifier le nombre de reducers
    if (reducers.length != collectionDeps.size()) {
        processingEnv.getMessager().printMessage(
            Diagnostic.Kind.ERROR,
            String.format(
                "@Computed field '%s': reducers count (%d) must match " +
                "collection dependency count (%d). " +
                "Collection dependencies: %s",
                field.getSimpleName(), 
                reducers.length, 
                collectionDeps.size(),
                collectionDeps
            ),
            field
        );
        return;
    }
    
    // 2. Vérifier que chaque path de collection finit par un champ simple
    for (String dep : collectionDeps) {
        if (!isValidCollectionPath(dep)) {
            processingEnv.getMessager().printMessage(
                Diagnostic.Kind.ERROR,
                String.format(
                    "@Computed field '%s': collection path '%s' must end with " +
                    "a simple field (e.g., 'orders.total', 'items.id'), not a collection.",
                    field.getSimpleName(), dep
                ),
                field
            );
        }
    }
}

/**
 * Vérifie qu'un path de collection est valide.
 * Un path valide contient au moins un '.' et le dernier segment
 * ne doit pas être reconnu comme une collection elle-même.
 * 
 * Note: Cette validation basique vérifie la syntaxe.
 * La validation sémantique (le champ existe-t-il?) est faite ailleurs.
 */
private boolean isValidCollectionPath(String path) {
    if (!path.contains(".")) {
        return false;
    }
    // Le path contient au moins un '.', donc format collection.field
    // La validation sémantique vérifiera si c'est bien un champ
    return true;
}
```

### 4. Génération des métadonnées

Inclure `reducers` dans la sortie :

**JSON :**
```json
{
  "computedFields": [
    {
      "dtoField": "totalSalaries",
      "dependsOn": ["departments.teams.employees.salary"],
      "reducers": ["SUM"],
      "methodReference": null
    }
  ]
}
```

**Code généré :**
```java
new ComputedField(
    "totalSalaries",
    new String[]{"departments.teams.employees.salary"},
    new String[]{"SUM"},
    null
)
```

### 5. API runtime enrichie

```java
public interface ComputedField {
    String dtoField();
    String[] dependsOn();
    String[] reducers();
    MethodReference methodReference();
    
    /** @return true si ce champ utilise des reducers */
    default boolean hasReducers() {
        return reducers() != null && reducers().length > 0;
    }
    
    /** @return le reducer pour une dépendance donnée, ou null */
    default String getReducerForDependency(String dependency) {
        if (!hasReducers() || !dependency.contains(".")) {
            return null;
        }
        int reducerIndex = 0;
        for (String dep : dependsOn()) {
            if (dep.equals(dependency)) {
                return reducers()[reducerIndex];
            }
            if (dep.contains(".")) {
                reducerIndex++;
            }
        }
        return null;
    }
    
    /** @return liste des dépendances collection avec leurs reducers */
    default List<CollectionDependency> getCollectionDependencies() {
        List<CollectionDependency> result = new ArrayList<>();
        int reducerIndex = 0;
        for (String dep : dependsOn()) {
            if (dep.contains(".")) {
                result.add(new CollectionDependency(
                    dep, 
                    hasReducers() ? reducers()[reducerIndex++] : null
                ));
            }
        }
        return result;
    }
}

public record CollectionDependency(String path, String reducer) {}
```

## Messages d'erreur

| Condition | Message |
|-----------|---------|
| Count mismatch | `reducers count (X) must match collection dependency count (Y)` |
| Path invalide | `collection path 'X' must end with a simple field, not a collection` |

## Tests

```java
// 1. Validation réussie
@Computed(dependsOn = {"orders.total"}, reducers = {"SUM"})
BigDecimal total; // ✓ Compile

// 2. Collections imbriquées OK
@Computed(dependsOn = {"dept.teams.employees.salary"}, reducers = {"AVG"})
BigDecimal avgSalary; // ✓ Compile (pas de limite de profondeur)

// 3. Erreur: count mismatch
@Computed(dependsOn = {"a.b", "c.d"}, reducers = {"SUM"})
// ✗ Error: reducers count (1) must match collection dependency count (2)

// 4. Compatibilité: sans reducers
@Computed(dependsOn = {"firstName", "lastName"})
String fullName; // ✓ Fonctionne comme avant

// 5. Test runtime
@Test
void shouldAccessReducers() {
    ComputedField cf = metadata.getComputedField("total").get();
    assertEquals("SUM", cf.getReducerForDependency("orders.total"));
    assertTrue(cf.hasReducers());
    
    var deps = cf.getCollectionDependencies();
    assertEquals(1, deps.size());
    assertEquals("orders.total", deps.get(0).path());
    assertEquals("SUM", deps.get(0).reducer());
}
```
